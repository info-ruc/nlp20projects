Learning Phrase Representations using RNN Encoder–Decoder

for Statistical Machine Translation

Kyunghyun Cho

Bart van Merri¨enboer Caglar Gulcehre

Universit´e de Montr´eal

Dzmitry Bahdanau

Jacobs University, Germany

4
1
0
2

 

p
e
S
3

 

 
 
]
L
C
.
s
c
[
 
 

3
v
8
7
0
1

.

6
0
4
1
:
v
i
X
r
a

firstname.lastname@umontreal.ca

d.bahdanau@jacobs-university.de

Fethi Bougares Holger Schwenk

Universit´e du Maine, France

Yoshua Bengio

Universit´e de Montr´eal, CIFAR Senior Fellow

firstname.lastname@lium.univ-lemans.fr

find.me@on.the.web

Abstract

In this paper, we propose a novel neu-
ral network model called RNN Encoder–
Decoder that consists of two recurrent
neural networks (RNN). One RNN en-
codes a sequence of symbols into a ﬁxed-
length vector representation, and the other
decodes the representation into another se-
quence of symbols. The encoder and de-
coder of the proposed model are jointly
trained to maximize the conditional prob-
ability of a target sequence given a source
sequence. The performance of a statisti-
cal machine translation system is empiri-
cally found to improve by using the con-
ditional probabilities of phrase pairs com-
puted by the RNN Encoder–Decoder as an
additional feature in the existing log-linear
model. Qualitatively, we show that the
proposed model learns a semantically and
syntactically meaningful representation of
linguistic phrases.

Introduction

1
Deep neural networks have shown great success in
various applications such as objection recognition
(see, e.g., (Krizhevsky et al., 2012)) and speech
recognition (see, e.g., (Dahl et al., 2012)). Fur-
thermore, many recent works showed that neu-
ral networks can be successfully used in a num-
ber of tasks in natural language processing (NLP).
These include, but are not limited to, language
modeling (Bengio et al., 2003), paraphrase detec-
tion (Socher et al., 2011) and word embedding ex-
traction (Mikolov et al., 2013). In the ﬁeld of sta-
tistical machine translation (SMT), deep neural
networks have begun to show promising results.
(Schwenk, 2012) summarizes a successful usage
of feedforward neural networks in the framework
of phrase-based SMT system.

Along this line of research on using neural net-
works for SMT, this paper focuses on a novel neu-
ral network architecture that can be used as a part
of the conventional phrase-based SMT system.
The proposed neural network architecture, which
we will refer to as an RNN Encoder–Decoder, con-
sists of two recurrent neural networks (RNN) that
act as an encoder and a decoder pair. The en-
coder maps a variable-length source sequence to a
ﬁxed-length vector, and the decoder maps the vec-
tor representation back to a variable-length target
sequence. The two networks are trained jointly to
maximize the conditional probability of the target
sequence given a source sequence. Additionally,
we propose to use a rather sophisticated hidden
unit in order to improve both the memory capacity
and the ease of training.

The proposed RNN Encoder–Decoder with a
novel hidden unit is empirically evaluated on the
task of translating from English to French. We
train the model to learn the translation probabil-
ity of an English phrase to a corresponding French
phrase. The model is then used as a part of a stan-
dard phrase-based SMT system by scoring each
phrase pair in the phrase table. The empirical eval-
uation reveals that this approach of scoring phrase
pairs with an RNN Encoder–Decoder improves
the translation performance.

We qualitatively analyze the trained RNN
Encoder–Decoder by comparing its phrase scores
with those given by the existing translation model.
The qualitative analysis shows that
the RNN
Encoder–Decoder is better at capturing the lin-
guistic regularities in the phrase table, indirectly
explaining the quantitative improvements in the
overall translation performance. The further anal-
ysis of the model reveals that the RNN Encoder–
Decoder learns a continuous space representation
of a phrase that preserves both the semantic and
syntactic structure of the phrase.

2 RNN Encoder–Decoder
2.1 Preliminary: Recurrent Neural Networks
A recurrent neural network (RNN) is a neural net-
work that consists of a hidden state h and an
optional output y which operates on a variable-
length sequence x = (x1, . . . , xT ). At each time
step t, the hidden state h(cid:104)t(cid:105) of the RNN is updated
by

h(cid:104)t(cid:105) = f(cid:0)h(cid:104)t−1(cid:105), xt

(cid:1) ,

(1)

is

a non-linear

activation func-
where f
tion.
f may be as simple as an element-
wise logistic sigmoid function and as com-
plex as a long short-term memory (LSTM)
unit (Hochreiter and Schmidhuber, 1997).

An RNN can learn a probability distribution
over a sequence by being trained to predict the
next symbol in a sequence. In that case, the output
at each timestep t is the conditional distribution
p(xt | xt−1, . . . , x1). For example, a multinomial
distribution (1-of-K coding) can be output using a
softmax activation function

p(xt,j = 1 | xt−1, . . . , x1) =

exp(cid:0)wjh(cid:104)t(cid:105)(cid:1)
j(cid:48)=1 exp(cid:0)wj(cid:48)h(cid:104)t(cid:105)(cid:1) ,
(cid:80)K

(2)

T(cid:89)

for all possible symbols j = 1, . . . , K, where wj
are the rows of a weight matrix W. By combining
these probabilities, we can compute the probabil-
ity of the sequence x using

p(x) =

p(xt | xt−1, . . . , x1).

(3)

t=1

From this learned distribution, it is straightfor-
ward to sample a new sequence by iteratively sam-
pling a symbol at each time step.

2.2 RNN Encoder–Decoder
In this paper, we propose a novel neural network
architecture that learns to encode a variable-length
sequence into a ﬁxed-length vector representation
and to decode a given ﬁxed-length vector rep-
resentation back into a variable-length sequence.
From a probabilistic perspective, this new model
is a general method to learn the conditional dis-
tribution over a variable-length sequence condi-
tioned on yet another variable-length sequence,
| x1, . . . , xT ), where one
e.g.

p(y1, . . . , yT (cid:48)

Figure 1: An illustration of the proposed RNN
Encoder–Decoder.

should note that the input and output sequence
lengths T and T (cid:48) may differ.

The encoder is an RNN that reads each symbol
of an input sequence x sequentially. As it reads
each symbol, the hidden state of the RNN changes
according to Eq. (1). After reading the end of
the sequence (marked by an end-of-sequence sym-
bol), the hidden state of the RNN is a summary c
of the whole input sequence.

The decoder of the proposed model is another
RNN which is trained to generate the output se-
quence by predicting the next symbol yt given the
hidden state h(cid:104)t(cid:105). However, unlike the RNN de-
scribed in Sec. 2.1, both yt and h(cid:104)t(cid:105) are also con-
ditioned on yt−1 and on the summary c of the input
sequence. Hence, the hidden state of the decoder
at time t is computed by,

h(cid:104)t(cid:105) = f(cid:0)h(cid:104)t−1(cid:105), yt−1, c(cid:1) ,

and similarly, the conditional distribution of the
next symbol is

P (yt|yt−1, yt−2, . . . , y1, c) = g(cid:0)h(cid:104)t(cid:105), yt−1, c(cid:1) .

for given activation functions f and g (the latter
must produce valid probabilities, e.g. with a soft-
max).

See Fig. 1 for a graphical depiction of the pro-

posed model architecture.

The two components of the proposed RNN
Encoder–Decoder are jointly trained to maximize
the conditional log-likelihood

N(cid:88)

n=1

max

θ

1
N

log pθ(yn | xn),

(4)

where θ is the set of the model parameters and
each (xn, yn) is an (input sequence, output se-
quence) pair from the training set.
In our case,
as the output of the decoder, starting from the in-
put, is differentiable, we can use a gradient-based
algorithm to estimate the model parameters.

Once the RNN Encoder–Decoder is trained, the
model can be used in two ways. One way is to use
the model to generate a target sequence given an
input sequence. On the other hand, the model can
be used to score a given pair of input and output
sequences, where the score is simply a probability
pθ(y | x) from Eqs. (3) and (4).
2.3 Hidden Unit that Adaptively Remembers

and Forgets

In addition to a novel model architecture, we also
propose a new type of hidden unit (f in Eq. (1))
that has been motivated by the LSTM unit but is
much simpler to compute and implement.1 Fig. 2
shows the graphical depiction of the proposed hid-
den unit.

Let us describe how the activation of the j-th
hidden unit is computed. First, the reset gate rj is
computed by

(cid:16)

[Wrx]j +(cid:2)Urh(cid:104)t−1(cid:105)(cid:3)

(cid:17)

j

,

(5)

rj = σ

where σ is the logistic sigmoid function, and [.]j
denotes the j-th element of a vector. x and ht−1
are the input and the previous hidden state, respec-
tively. Wr and Ur are weight matrices which are
learned.

Similarly, the update gate zj is computed by

(cid:16)

[Wzx]j +(cid:2)Uzh(cid:104)t−1(cid:105)(cid:3)

(cid:17)

j

zj = σ

.

(6)

The actual activation of the proposed unit hj is

then computed by

(cid:104)t−1(cid:105)
(cid:104)t(cid:105)
j = zjh
j

h

+ (1 − zj)˜h

(cid:104)t(cid:105)
j ,

[Wx]j +(cid:2)U(cid:0)r (cid:12) h(cid:104)t−1(cid:105)(cid:1)(cid:3)

(cid:16)

where
(cid:104)t(cid:105)
˜h
j = φ

(7)

.

(8)

(cid:17)

j

In this formulation, when the reset gate is close
to 0, the hidden state is forced to ignore the pre-
vious hidden state and reset with the current input
1 The LSTM unit, which has shown impressive results in
several applications such as speech recognition, has a mem-
ory cell and four gating units that adaptively control the in-
formation ﬂow inside the unit, compared to only two gating
units in the proposed hidden unit. For details on LSTM net-
works, see, e.g., (Graves, 2012).

Figure 2: An illustration of the proposed hidden
activation function. The update gate z selects
whether the hidden state is to be updated with
a new hidden state ˜h. The reset gate r decides
whether the previous hidden state is ignored. See
Eqs. (5)–(8) for the detailed equations of r, z, h
and ˜h.

only. This effectively allows the hidden state to
drop any information that is found to be irrelevant
later in the future, thus, allowing a more compact
representation.

On the other hand, the update gate controls how
much information from the previous hidden state
will carry over to the current hidden state. This
acts similarly to the memory cell in the LSTM
network and helps the RNN to remember long-
term information. Furthermore, this may be con-
sidered an adaptive variant of a leaky-integration
unit (Bengio et al., 2013).

As each hidden unit has separate reset and up-
date gates, each hidden unit will learn to capture
dependencies over different time scales. Those
units that learn to capture short-term dependencies
will tend to have reset gates that are frequently ac-
tive, but those that capture longer-term dependen-
cies will have update gates that are mostly active.
In our preliminary experiments, we found that
it is crucial to use this new unit with gating units.
We were not able to get meaningful result with an
oft-used tanh unit without any gating.

3 Statistical Machine Translation

In a commonly used statistical machine translation
system (SMT), the goal of the system (decoder,
speciﬁcally) is to ﬁnd a translation f given a source
sentence e, which maximizes

p(f | e) ∝ p(e | f )p(f ),

where the ﬁrst term at the right hand side is called
translation model and the latter language model
(see, e.g., (Koehn, 2005)).
In practice, however,
most SMT systems model log p(f | e) as a log-
linear model with additional features and corre-

sponding weights:

N(cid:88)

log p(f | e) =

wnfn(f , e) + log Z(e),

(9)

n=1

where fn and wn are the n-th feature and weight,
respectively. Z(e) is a normalization constant that
does not depend on the weights. The weights are
often optimized to maximize the BLEU score on a
development set.

SMT

(Koehn et al., 2003)

In

phrase-based
in

the
framework
introduced
and
(Marcu and Wong, 2002),
the translation model
log p(e | f ) is factorized into the translation
probabilities of matching phrases in the source
and target sentences.2 These probabilities are
once again considered additional features in the
log-linear model (see Eq. (9)) and are weighted
accordingly to maximize the BLEU score.

Since the neural net language model was pro-
posed in (Bengio et al., 2003), neural networks
have been used widely in SMT systems.
In
many cases, neural networks have been used to
rescore translation hypotheses (n-best lists) (see,
e.g., (Schwenk et al., 2006)). Recently, however,
there has been interest in training neural networks
to score the translated sentence (or phrase pairs)
using a representation of the source sentence as
an additional input. See, e.g., (Schwenk, 2012),
(Son et al., 2012) and (Zou et al., 2013).

3.1 Scoring Phrase Pairs with RNN

Encoder–Decoder

Here we propose to train the RNN Encoder–
Decoder (see Sec. 2.2) on a table of phrase pairs
and use its scores as additional features in the log-
linear model in Eq. (9) when tuning the SMT de-
coder.

When we train the RNN Encoder–Decoder, we
ignore the (normalized) frequencies of each phrase
pair in the original corpora. This measure was
taken in order (1) to reduce the computational ex-
pense of randomly selecting phrase pairs from a
large phrase table according to the normalized fre-
quencies and (2) to ensure that the RNN Encoder–
Decoder does not simply learn to rank the phrase
pairs according to their numbers of occurrences.
One underlying reason for this choice was that the
existing translation probability in the phrase ta-
ble already reﬂects the frequencies of the phrase

2 Without loss of generality, from here on, we refer to

p(e | f ) for each phrase pair as a translation model as well

pairs in the original corpus. With a ﬁxed capacity
of the RNN Encoder–Decoder, we try to ensure
that most of the capacity of the model is focused
toward learning linguistic regularities, i.e., distin-
guishing between plausible and implausible trans-
lations, or learning the “manifold” (region of prob-
ability concentration) of plausible translations.

Once the RNN Encoder–Decoder is trained, we
add a new score for each phrase pair to the exist-
ing phrase table. This allows the new scores to en-
ter into the existing tuning algorithm with minimal
additional overhead in computation.

As Schwenk pointed out in (Schwenk, 2012),
it is possible to completely replace the existing
phrase table with the proposed RNN Encoder–
Decoder. In that case, for a given source phrase,
the RNN Encoder–Decoder will need to generate
a list of (good) target phrases. This requires, how-
ever, an expensive sampling procedure to be per-
formed repeatedly.
In this paper, thus, we only
consider rescoring the phrase pairs in the phrase
table.

3.2 Related Approaches: Neural Networks in

Machine Translation

Before presenting the empirical results, we discuss
a number of recent works that have proposed to
use neural networks in the context of SMT.

Schwenk in (Schwenk, 2012) proposed a simi-
lar approach of scoring phrase pairs. Instead of the
RNN-based neural network, he used a feedforward
neural network that has ﬁxed-size inputs (7 words
in his case, with zero-padding for shorter phrases)
and ﬁxed-size outputs (7 words in the target lan-
guage). When it is used speciﬁcally for scoring
phrases for the SMT system, the maximum phrase
length is often chosen to be small. However, as the
length of phrases increases or as we apply neural
networks to other variable-length sequence data,
it is important that the neural network can han-
dle variable-length input and output. The pro-
posed RNN Encoder–Decoder is well-suited for
these applications.

Similar

to (Schwenk, 2012), Devlin et al.
(Devlin et al., 2014) proposed to use a feedfor-
ward neural network to model a translation model,
however, by predicting one word in a target phrase
at a time. They reported an impressive improve-
ment, but their approach still requires the maxi-
mum length of the input phrase (or context words)
to be ﬁxed a priori.

Although it is not exactly a neural network they
train, the authors of (Zou et al., 2013) proposed
to learn a bilingual embedding of words/phrases.
They use the learned embedding to compute the
distance between a pair of phrases which is used
as an additional score of the phrase pair in an SMT
system.

In (Chandar et al., 2014), a feedforward neural
network was trained to learn a mapping from a
bag-of-words representation of an input phrase to
an output phrase. This is closely related to both the
proposed RNN Encoder–Decoder and the model
proposed in (Schwenk, 2012), except that their in-
put representation of a phrase is a bag-of-words.
A similar approach of using bag-of-words repre-
sentations was proposed in (Gao et al., 2013) as
well. Earlier, a similar encoder–decoder model us-
ing two recursive neural networks was proposed
in (Socher et al., 2011), but their model was re-
stricted to a monolingual setting, i.e. the model
reconstructs an input sentence. More recently, an-
other encoder–decoder model using an RNN was
proposed in (Auli et al., 2013), where the de-
coder is conditioned on a representation of either
a source sentence or a source context.

One important difference between the pro-
posed RNN Encoder–Decoder and the approaches
in (Zou et al., 2013) and (Chandar et al., 2014) is
that the order of the words in source and tar-
get phrases is taken into account. The RNN
Encoder–Decoder naturally distinguishes between
sequences that have the same words but in a differ-
ent order, whereas the aforementioned approaches
effectively ignore order information.

The closest approach related to the proposed
RNN Encoder–Decoder is the Recurrent Contin-
uous Translation Model (Model 2) proposed in
(Kalchbrenner and Blunsom, 2013).
In their pa-
per, they proposed a similar model that consists
of an encoder and decoder. The difference with
our model is that they used a convolutional n-gram
model (CGM) for the encoder and the hybrid of
an inverse CGM and a recurrent neural network
for the decoder. They, however, evaluated their
model on rescoring the n-best list proposed by the
conventional SMT system and computing the per-
plexity of the gold standard translations.

4 Experiments

We evaluate our approach on the English/French
translation task of the WMT’14 workshop.

4.1 Data and Baseline System
Large amounts of resources are available to build
an English/French SMT system in the framework
of the WMT’14 translation task. The bilingual
corpora include Europarl (61M words), news com-
mentary (5.5M), UN (421M), and two crawled
corpora of 90M and 780M words respectively.
The last two corpora are quite noisy. To train
the French language model, about 712M words of
crawled newspaper material is available in addi-
tion to the target side of the bitexts. All the word
counts refer to French words after tokenization.

It is commonly acknowledged that training sta-
tistical models on the concatenation of all this
data does not necessarily lead to optimal per-
formance, and results in extremely large mod-
els which are difﬁcult to handle.
Instead, one
should focus on the most relevant subset of the
data for a given task. We have done so by
applying the data selection method proposed in
(Moore and Lewis, 2010), and its extension to bi-
texts (Axelrod et al., 2011). By these means we
selected a subset of 418M words out of more
than 2G words for language modeling and a
subset of 348M out of 850M words for train-
ing the RNN Encoder–Decoder. We used the
test set newstest2012 and 2013 for data
selection and weight
tuning with MERT, and
newstest2014 as our test set. Each set has
more than 70 thousand words and a single refer-
ence translation.

For training the neural networks, including the
proposed RNN Encoder–Decoder, we limited the
source and target vocabulary to the most frequent
15,000 words for both English and French. This
covers approximately 93% of the dataset. All the
out-of-vocabulary words were mapped to a special
token ([UNK]).

The baseline phrase-based SMT system was
built using Moses with default settings. This sys-
tem achieves a BLEU score of 30.64 and 33.3 on
the development and test sets, respectively (see Ta-
ble 1).

4.1.1 RNN Encoder–Decoder
The RNN Encoder–Decoder used in the experi-
ment had 1000 hidden units with the proposed
gates at the encoder and at the decoder. The in-
put matrix between each input symbol x(cid:104)t(cid:105) and the
hidden unit is approximated with two lower-rank
matrices, and the output matrix is approximated

Models

dev
30.64
Baseline
31.20
RNN
31.48
CSLM + RNN
CSLM + RNN + WP 31.50

BLEU

test
33.30
33.87
34.64
34.54

Table 1: BLEU scores computed on the develop-
ment and test sets using different combinations of
approaches. WP denotes a word penalty, where
we penalizes the number of unknown words to
neural networks.

similarly. We used rank-100 matrices, equivalent
to learning an embedding of dimension 100 for
each word. The activation function used for ˜h in
Eq. (8) is a hyperbolic tangent function. The com-
putation from the hidden state in the decoder to
the output is implemented as a deep neural net-
work (Pascanu et al., 2014) with a single interme-
diate layer having 500 maxout units each pooling
2 inputs (Goodfellow et al., 2013).

All the weight parameters in the RNN Encoder–
Decoder were initialized by sampling from an
isotropic zero-mean (white) Gaussian distribution
with its standard deviation ﬁxed to 0.01, except
for the recurrent weight parameters. For the re-
current weight matrices, we ﬁrst sampled from a
white Gaussian distribution and used its left singu-
lar vectors matrix, following (Saxe et al., 2014).

We used Adadelta and stochastic gradient
descent
to train the RNN Encoder–Decoder
with hyperparameters  = 10−6 and ρ =
0.95 (Zeiler, 2012). At each update, we used 64
randomly selected phrase pairs from a phrase ta-
ble (which was created from 348M words). The
model was trained for approximately three days.

Details of the architecture used in the experi-
ments are explained in more depth in the supple-
mentary material.

4.1.2 Neural Language Model
In order to assess the effectiveness of scoring
phrase pairs with the proposed RNN Encoder–
Decoder, we also tried a more traditional approach
of using a neural network for learning a target
language model (CSLM) (Schwenk, 2007). Espe-
cially, the comparison between the SMT system
using CSLM and that using the proposed approach
of phrase scoring by RNN Encoder–Decoder will
clarify whether the contributions from multiple
neural networks in different parts of the SMT sys-

tem add up or are redundant.

We trained the CSLM model on 7-grams
from the target corpus.
Each input word
was projected into the embedding space R512,
and they were concatenated to form a 3072-
dimensional vector. The concatenated vector was
fed through two rectiﬁed layers (of size 1536 and
1024) (Glorot et al., 2011). The output layer was
a simple softmax layer (see Eq. (2)). All the
weight parameters were initialized uniformly be-
tween −0.01 and 0.01, and the model was trained
until the validation perplexity did not improve for
10 epochs. After training, the language model
achieved a perplexity of 45.80. The validation set
was a random selection of 0.1% of the corpus. The
model was used to score partial translations dur-
ing the decoding process, which generally leads to
higher gains in BLEU score than n-best list rescor-
ing (Vaswani et al., 2013).

To address the computational complexity of
using a CSLM in the decoder a buffer was
used to aggregate n-grams during the stack-
search performed by the decoder. Only when
is full, or a stack is about
the buffer
to
be pruned,
the n-grams are scored by the
CSLM. This allows us to perform fast matrix-
matrix multiplication on GPU using Theano
(Bergstra et al., 2010; Bastien et al., 2012).

Figure 3: The visualization of phrase pairs accord-
ing to their scores (log-probabilities) by the RNN
Encoder–Decoder and the translation model.

4.2 Quantitative Analysis
We tried the following combinations:

1. Baseline conﬁguration
2. Baseline + RNN
3. Baseline + CSLM + RNN
4. Baseline + CSLM + RNN + Word penalty

Source
at the end of the

for the ﬁrst time

in the United States
and
, as well as
one of the most

Source
, Minister of Commu-
nications and Trans-
port
did not comply with
the

parts of the world .

the past few days .

on Friday and Satur-
day

Translation Model
[a la ﬁn de la] [´r la ﬁn des ann´ees] [ˆetre sup-
prim´es `a la ﬁn de la]
[r c(cid:13) pour la premir¨ere fois] [´et´e donn´es pour
la premi`ere fois] [´et´e comm´emor´ee pour la
premi`ere fois]
[? aux ?tats-Unis et] [´et´e ouvertes aux ´Etats-
Unis et] [´et´e constat´ees aux ´Etats-Unis et]
[?s , qu’] [?s , ainsi que] [?re aussi bien que]
[?t ?l’ un des plus] [?l’ un des plus] [ˆetre retenue
comme un de ses plus]

(a) Long, frequent source phrases

RNN Encoder–Decoder
[`a la ﬁn du] [`a la ﬁn des] [`a la ﬁn de la]

[pour la premi`ere fois] [pour la premi`ere fois ,]
[pour la premi`ere fois que]

[aux Etats-Unis et] [des Etats-Unis et] [des
´Etats-Unis et]
[, ainsi qu’] [, ainsi que] [, ainsi que les]
[l’ un des] [le] [un des]

Translation Model
[Secr´etaire aux communications et aux trans-
ports :] [Secr´etaire aux communications et aux
transports]
[vestimentaire , ne correspondaient pas `a des]
[susmentionn´ee n’
´etait pas conforme aux]
[pr´esent´ees n’ ´etaient pas conformes `a la]
[ c(cid:13) gions du monde .] [r´egions du monde con-
sid´er´ees .] [r´egion du monde consid´er´ee .]
[le petit texte .] [cours des tout derniers jours .]
[les tout derniers jours .]
[vendredi et samedi `a la] [vendredi et samedi `a]
[se d´eroulera vendredi et samedi ,]

(b) Long, rare source phrases

RNN Encoder–Decoder
[Secr´etaire aux communications et aux trans-
ports] [Secr´etaire aux communications et aux
transports :]
[n’ ont pas respect´e les] [n’ ´etait pas conforme
aux] [n’ ont pas respect´e la]

[les parties du monde .]

[parties du monde .]
[des parties du monde .]
[ces derniers jours .] [les derniers jours .] [cours
des derniers jours .]
[le vendredi et le samedi] [le vendredi et samedi]
[vendredi et samedi]

Table 2: The top scoring target phrases for a small set of source phrases according to the translation
model (direct translation probability) and by the RNN Encoder–Decoder. Source phrases were randomly
selected from phrases with 4 or more words. ? denotes an incomplete (partial) character. r is a Cyrillic
letter ghe.

The results are presented in Table 1. As ex-
pected, adding features computed by neural net-
works consistently improves the performance over
the baseline performance.

The best performance was achieved when we
used both CSLM and the phrase scores from the
RNN Encoder–Decoder. This suggests that the
contributions of the CSLM and the RNN Encoder–
Decoder are not too correlated and that one can
expect better results by improving each method in-
dependently. Furthermore, we tried penalizing the
number of words that are unknown to the neural
networks (i.e. words which are not in the short-
list). We do so by simply adding the number of
unknown words as an additional feature the log-
linear model in Eq. (9).3 However, in this case we
3 To understand the effect of the penalty, consider the set
of all words in the 15,000 large shortlist, SL. All words xi /∈
SL are replaced by a special token [UNK] before being scored
by the neural networks. Hence, the conditional probability of
any xi

t /∈ SL is actually given by the model as
p (xt = [UNK] | x<t) = p (xt /∈ SL | x<t)
t | x<t
xi

(cid:17) ≥ p

(cid:88)

t | x<t
xj

p

(cid:16)

(cid:16)

(cid:17)

,

=

t /∈SL
xj

where x<t is a shorthand notation for xt−1, . . . , x1.

were not able to achieve better performance on the
test set, but only on the development set.

4.3 Qualitative Analysis
In order to understand where the performance im-
provement comes from, we analyze the phrase pair
scores computed by the RNN Encoder–Decoder
against the corresponding p(f | e) from the trans-
lation model. Since the existing translation model
relies solely on the statistics of the phrase pairs in
the corpus, we expect its scores to be better esti-
mated for the frequent phrases but badly estimated
for rare phrases. Also, as we mentioned earlier
in Sec. 3.1, we further expect the RNN Encoder–
Decoder which was trained without any frequency
information to score the phrase pairs based rather
on the linguistic regularities than on the statistics
of their occurrences in the corpus.

We focus on those pairs whose source phrase is
long (more than 3 words per source phrase) and

As a result, the probability of words not in the shortlist is
always overestimated. It is possible to address this issue by
backing off to an existing model that contain non-shortlisted
words (see (Schwenk, 2007)) In this paper, however, we opt
for introducing a word penalty instead, which counteracts the
word probability overestimation.

Source
at the end of the
for the ﬁrst time
in the United States and
, as well as
one of the most

Samples from RNN Encoder–Decoder
[`a la ﬁn de la] (×11)
[pour la premi`ere fois] (×24) [pour la premi`ere fois que] (×2)
[aux ´Etats-Unis et] (×6) [dans les ´Etats-Unis et] (×4)
[, ainsi que] [,] [ainsi que] [, ainsi qu’] [et UNK]
[l’ un des plus] (×9) [l’ un des] (×5) [l’ une des plus] (×2)

(a) Long, frequent source phrases

Source
, Minister of Communica-
tions and Transport
did not comply with the
parts of the world .
the past few days .
on Friday and Saturday

Samples from RNN Encoder–Decoder
[ , ministre des communications et le transport] (×13)
[n’ tait pas conforme aux] [n’ a pas respect l’] (×2) [n’ a pas respect la] (×3)
[arts du monde .] (×11) [des arts du monde .] (×7)
[quelques jours .] (×5) [les derniers jours .] (×5) [ces derniers jours .] (×2)
[vendredi et samedi] (×5) [le vendredi et samedi] (×7) [le vendredi et le samedi] (×4)

(b) Long, rare source phrases

Table 3: Samples generated from the RNN Encoder–Decoder for each source phrase used in Table 2. We
show the top-5 target phrases out of 50 samples. They are sorted by the RNN Encoder–Decoder scores.

Figure 4: 2–D embedding of the learned word representation. The left one shows the full embedding
space, while the right one shows a zoomed-in view of one region (color–coded). For more plots, see the
supplementary material.

frequent. For each such source phrase, we look
at the target phrases that have been scored high
either by the translation probability p(f | e) or
by the RNN Encoder–Decoder. Similarly, we per-
form the same procedure with those pairs whose
source phrase is long but rare in the corpus.

Table 2 lists the top-3 target phrases per source
phrase favored either by the translation model
or by the RNN Encoder–Decoder. The source
phrases were randomly chosen among long ones
having more than 4 or 5 words.

In most cases, the choices of the target phrases
by the RNN Encoder–Decoder are closer to ac-
tual or literal translations. We can observe that the
RNN Encoder–Decoder prefers shorter phrases in
general.

Interestingly, many phrase pairs were scored
similarly by both the translation model and the
RNN Encoder–Decoder, but there were as many

other phrase pairs that were scored radically dif-
ferent (see Fig. 3). This could arise from the
proposed approach of training the RNN Encoder–
Decoder on a set of unique phrase pairs, discour-
aging the RNN Encoder–Decoder from learning
simply the frequencies of the phrase pairs from the
corpus, as explained earlier.

Furthermore, in Table 3, we show for each of
the source phrases in Table 2, the generated sam-
ples from the RNN Encoder–Decoder. For each
source phrase, we generated 50 samples and show
the top-ﬁve phrases accordingly to their scores.
We can see that the RNN Encoder–Decoder is
able to propose well-formed target phrases with-
out looking at the actual phrase table. Importantly,
the generated phrases do not overlap completely
with the target phrases from the phrase table. This
encourages us to further investigate the possibility
of replacing the whole or a part of the phrase table

Figure 5: 2–D embedding of the learned phrase representation. The top left one shows the full represen-
tation space (5000 randomly selected points), while the other three ﬁgures show the zoomed-in view of
speciﬁc regions (color–coded).

with the proposed RNN Encoder–Decoder in the
future.

4.4 Word and Phrase Representations
Since the proposed RNN Encoder–Decoder is not
speciﬁcally designed only for the task of machine
translation, here we brieﬂy look at the properties
of the trained model.

space

embeddings

(See,

language models

It has been known for

some time that
continuous
using
neural networks are able to learn seman-
tically meaningful
e.g.,
(Bengio et al., 2003; Mikolov et al., 2013)). Since
the proposed RNN Encoder–Decoder also projects
to and maps back from a sequence of words into
a continuous space vector, we expect to see a
similar property with the proposed model as well.
The left plot in Fig. 4 shows the 2–D embedding
of the words using the word embedding matrix
learned by the RNN Encoder–Decoder. The pro-
jection was done by the recently proposed Barnes-
Hut-SNE (van der Maaten, 2013). We can clearly
see that semantically similar words are clustered

with each other (see the zoomed-in plots in Fig. 4).
The proposed RNN Encoder–Decoder naturally
generates a continuous-space representation of a
phrase. The representation (c in Fig. 1) in this
case is a 1000-dimensional vector. Similarly to the
word representations, we visualize the representa-
tions of the phrases that consists of four or more
words using the Barnes-Hut-SNE in Fig. 5.

From the visualization, it is clear that the RNN
Encoder–Decoder captures both semantic and syn-
tactic structures of the phrases. For instance, in
the bottom-left plot, most of the phrases are about
the duration of time, while those phrases that are
syntactically similar are clustered together. The
bottom-right plot shows the cluster of phrases that
are semantically similar (countries or regions). On
the other hand, the top-right plot shows the phrases
that are syntactically similar.

5 Conclusion

In this paper, we proposed a new neural network
architecture, called an RNN Encoder–Decoder
that is able to learn the mapping from a sequence

of an arbitrary length to another sequence, possi-
bly from a different set, of an arbitrary length. The
proposed RNN Encoder–Decoder is able to either
score a pair of sequences (in terms of a conditional
probability) or generate a target sequence given a
source sequence. Along with the new architecture,
we proposed a novel hidden unit that includes a re-
set gate and an update gate that adaptively control
how much each hidden unit remembers or forgets
while reading/generating a sequence.

We evaluated the proposed model with the task
of statistical machine translation, where we used
the RNN Encoder–Decoder to score each phrase
pair in the phrase table. Qualitatively, we were
able to show that the new model is able to cap-
ture linguistic regularities in the phrase pairs well
and also that the RNN Encoder–Decoder is able to
propose well-formed target phrases.

The scores by the RNN Encoder–Decoder were
found to improve the overall translation perfor-
mance in terms of BLEU scores. Also, we
found that the contribution by the RNN Encoder–
Decoder is rather orthogonal to the existing ap-
proach of using neural networks in the SMT sys-
tem, so that we can improve further the perfor-
mance by using, for instance, the RNN Encoder–
Decoder and the neural net language model to-
gether.

Our qualitative analysis of the trained model
shows that it indeed captures the linguistic regu-
larities in multiple levels i.e. at the word level as
well as phrase level. This suggests that there may
be more natural language related applications that
may beneﬁt from the proposed RNN Encoder–
Decoder.

The proposed architecture has large potential
for further improvement and analysis. One ap-
proach that was not investigated here is to re-
place the whole, or a part of the phrase table by
letting the RNN Encoder–Decoder propose target
phrases. Also, noting that the proposed model is
not limited to being used with written language,
it will be an important future research to apply the
proposed architecture to other applications such as
speech transcription.

Acknowledgments

KC, BM, CG, DB and YB would like to thank
NSERC, Calcul Qu´ebec, Compute Canada, the
Canada Research Chairs and CIFAR. FB and HS
were partially funded by the European Commis-

sion under the project MateCat, and by DARPA
under the BOLT project.

References
[Auli et al.2013] Michael Auli, Michel Galley, Chris
Quirk, and Geoffrey Zweig. 2013. Joint language
and translation modeling with recurrent neural net-
In Proceedings of the ACL Conference on
works.
Empirical Methods in Natural Language Processing
(EMNLP), pages 1044–1054.

[Axelrod et al.2011] Amittai Axelrod, Xiaodong He,
and Jianfeng Gao. 2011. Domain adaptation via
pseudo in-domain data selection. In Proceedings of
the ACL Conference on Empirical Methods in Natu-
ral Language Processing (EMNLP), pages 355–362.

[Bastien et al.2012] Fr´ed´eric Bastien, Pascal Lamblin,
Razvan Pascanu, James Bergstra, Ian J. Goodfellow,
Arnaud Bergeron, Nicolas Bouchard, and Yoshua
Bengio. 2012. Theano: new features and speed im-
provements. Deep Learning and Unsupervised Fea-
ture Learning NIPS 2012 Workshop.

[Bengio et al.2003] Yoshua Bengio, R´ejean Ducharme,
Pascal Vincent, and Christian Janvin. 2003. A neu-
ral probabilistic language model. J. Mach. Learn.
Res., 3:1137–1155, March.

[Bengio et al.2013] Y.

N.

Bengio,

Boulanger-
Lewandowski, and R. Pascanu. 2013. Advances
In Proceedings
in optimizing recurrent networks.
of the 38th International Conference on Acoustics,
Speech, and Signal Processing (ICASSP 2013),
May.

[Bergstra et al.2010] James Bergstra, Olivier Breuleux,
Fr´ed´eric Bastien, Pascal Lamblin, Razvan Pascanu,
Guillaume Desjardins, Joseph Turian, David Warde-
Farley, and Yoshua Bengio. 2010. Theano: a CPU
and GPU math expression compiler. In Proceedings
of the Python for Scientiﬁc Computing Conference
(SciPy), June. Oral Presentation.

[Chandar et al.2014] Sarath Chandar, Stanislas Lauly,
Hugo Larochelle, Mitesh Khapra, Balaraman Ravin-
dran, Vikas Raykar, and Amrita Saha. 2014. An au-
toencoder approach to learning bilingual word repre-
sentations. arXiv:1402.1454 [cs.CL], Febru-
ary.

[Dahl et al.2012] George E. Dahl, Dong Yu, Li Deng,
and Alex Acero. 2012. Context-dependent pre-
trained deep neural networks for large vocabulary
IEEE Transactions on Audio,
speech recognition.
Speech, and Language Processing, 20(1):33–42.

Rabih

[Devlin et al.2014] Jacob Devlin,

Zbib,
Zhongqiang Huang, Thomas Lamar, Richard
Schwartz, , and John Makhoul. 2014. Fast and
robust neural network joint models for statistical
In Proceedings of the ACL
machine translation.
2014 Conference, ACL ’14, pages 1370–1380.

[Gao et al.2013] Jianfeng Gao, Xiaodong He, Wen tau
Yih, and Li Deng. 2013. Learning semantic repre-
sentations for the phrase translation model. Techni-
cal report, Microsoft Research.

[Glorot et al.2011] X. Glorot, A. Bordes, and Y. Ben-
gio. 2011. Deep sparse rectiﬁer neural networks. In
AISTATS’2011.

[Goodfellow et al.2013] Ian J. Goodfellow, David
Warde-Farley, Mehdi Mirza, Aaron Courville, and
Yoshua Bengio.
In
ICML’2013.

2013. Maxout networks.

[Graves2012] Alex Graves.

Supervised Se-
quence Labelling with Recurrent Neural Networks.
Studies in Computational Intelligence. Springer.

2012.

[Hochreiter and Schmidhuber1997] S. Hochreiter and
J. Schmidhuber. 1997. Long short-term memory.
Neural Computation, 9(8):1735–1780.

[Kalchbrenner and Blunsom2013] Nal Kalchbrenner
and Phil Blunsom. 2013. Two recurrent continuous
translation models. In Proceedings of the ACL Con-
ference on Empirical Methods in Natural Language
Processing (EMNLP), pages 1700–1709.

[Koehn et al.2003] Philipp Koehn, Franz Josef Och,
and Daniel Marcu. 2003. Statistical phrase-based
translation. In Proceedings of the 2003 Conference
of the North American Chapter of the Association
for Computational Linguistics on Human Language
Technology - Volume 1, NAACL ’03, pages 48–54.

[Koehn2005] P. Koehn. 2005. Europarl: A parallel cor-
pus for statistical machine translation. In Machine
Translation Summit X, pages 79–86, Phuket, Thai-
land.

[Krizhevsky et al.2012] Alex

2012.

Krizhevsky,

Ilya
Sutskever, and Geoffrey Hinton.
Ima-
geNet classiﬁcation with deep convolutional neural
In Advances in Neural Information
networks.
Processing Systems 25 (NIPS’2012).

[Marcu and Wong2002] Daniel Marcu and William
2002. A phrase-based, joint probability
Wong.
In Pro-
model for statistical machine translation.
ceedings of the ACL-02 Conference on Empirical
Methods in Natural Language Processing - Volume
10, EMNLP ’02, pages 133–139.

[Mikolov et al.2013] Tomas Mikolov, Ilya Sutskever,
Kai Chen, Greg Corrado, and Jeff Dean. 2013. Dis-
tributed representations of words and phrases and
their compositionality. In Advances in Neural Infor-
mation Processing Systems 26, pages 3111–3119.

2010.

[Moore and Lewis2010] Robert C. Moore and William
Intelligent selection of language
Lewis.
In Proceedings of the ACL
model training data.
2010 Conference Short Papers, ACLShort ’10,
pages 220–224, Stroudsburg, PA, USA.

[Pascanu et al.2014] R. Pascanu, C. Gulcehre, K. Cho,
and Y. Bengio. 2014. How to construct deep recur-
rent neural networks. In Proceedings of the Second
International Conference on Learning Representa-
tions (ICLR 2014), April.

[Saxe et al.2014] Andrew M. Saxe, James L. McClel-
land, and Surya Ganguli. 2014. Exact solutions
to the nonlinear dynamics of learning in deep lin-
ear neural networks. In Proceedings of the Second
International Conference on Learning Representa-
tions (ICLR 2014), April.

[Schwenk et al.2006] Holger Schwenk, Marta R. Costa-
Juss`a, and Jos´e A. R. Fonollosa. 2006. Continuous
space language models for the iwslt 2006 task. In
IWSLT, pages 166–173.

[Schwenk2007] Holger Schwenk. 2007. Continuous
space language models. Comput. Speech Lang.,
21(3):492–518, July.

[Schwenk2012] Holger Schwenk. 2012. Continuous
space translation models for phrase-based statisti-
cal machine translation. In Martin Kay and Chris-
tian Boitet, editors, Proceedings of the 24th Inter-
national Conference on Computational Linguistics
(COLIN), pages 1071–1080.

[Socher et al.2011] Richard Socher, Eric H. Huang, Jef-
frey Pennington, Andrew Y. Ng, and Christopher D.
Manning. 2011. Dynamic pooling and unfolding
recursive autoencoders for paraphrase detection. In
Advances in Neural Information Processing Systems
24.

[Son et al.2012] Le Hai Son, Alexandre Allauzen, and
Franc¸ois Yvon. 2012. Continuous space transla-
tion models with neural networks. In Proceedings of
the 2012 Conference of the North American Chap-
ter of the Association for Computational Linguistics:
Human Language Technologies, NAACL HLT ’12,
pages 39–48, Stroudsburg, PA, USA.

[van der Maaten2013] Laurens van der Maaten. 2013.
In Proceedings of the First Inter-
Barnes-hut-sne.
national Conference on Learning Representations
(ICLR 2013), May.

[Vaswani et al.2013] Ashish Vaswani, Yinggong Zhao,
Victoria Fossum, and David Chiang. 2013. De-
coding with large-scale neural language models im-
proves translation. Proceedings of the Conference
on Empirical Methods in Natural Language Pro-
cessing, pages 1387–1392.

[Zeiler2012] Matthew D. Zeiler. 2012. ADADELTA:
an adaptive learning rate method. Technical report,
arXiv 1212.5701.

Richard

[Zou et al.2013] Will Y. Zou,

Socher,
Daniel M. Cer, and Christopher D. Manning.
2013. Bilingual word embeddings for phrase-based
In Proceedings of the ACL
machine translation.
Conference on Empirical Methods
in Natural
Language Processing (EMNLP), pages 1393–1398.

A RNN Encoder–Decoder
In this document, we describe in detail the architecture of the RNN Encoder–Decoder used in the exper-
iments.

Let us denote an source phrase by X = (x1, x2, . . . , xN ) and a target phrase by Y =
(y1, y2, . . . , yM ). Each phrase is a sequence of K-dimensional one-hot vectors, such that only one
element of the vector is 1 and all the others are 0. The index of the active (1) element indicates the word
represented by the vector.

A.1 Encoder
Each word of the source phrase is embedded in a 500-dimensional vector space: e(xi) ∈ R500. e(x) is
used in Sec. 4.4 to visualize the words.

The hidden state of an encoder consists of 1000 hidden units, and each one of them at time t is

computed by

where

(cid:104)t−1(cid:105)
(cid:104)t(cid:105)
h
j = zjh
j

(cid:104)t(cid:105)
+ (1 − zj)˜h
j ,

(cid:16)
[We(xt)]j +(cid:2)U(cid:0)r (cid:12) h(cid:104)t−1(cid:105)(cid:1)(cid:3)
[Wze(xt)]j +(cid:2)Uzh(cid:104)t−1(cid:105)(cid:3)
[Wre(xt)]j +(cid:2)Urh(cid:104)t−1(cid:105)(cid:3)

(cid:17)
(cid:17)

.

,

j

(cid:16)
(cid:16)

j

(cid:17)

,

j

(cid:104)t(cid:105)
˜h
j = tanh

zj =σ

rj =σ

σ and (cid:12) are a logistic sigmoid function and an element-wise multiplication, respectively. To make the
(cid:104)0(cid:105)
equations uncluttered, we omit biases. The initial hidden state h
j

Once the hidden state at the N step (the end of the source phrase) is computed, the representation of

is ﬁxed to 0.

the source phrase c is

A.1.1 Decoder
The decoder starts by initializing the hidden state with

.

(cid:16)

Vh(cid:104)N(cid:105)(cid:17)
= tanh(cid:0)V(cid:48)c(cid:1) ,

c = tanh

h(cid:48)(cid:104)0(cid:105)

where we will use ·(cid:48) to distinguish parameters of the decoder from those of the encoder.

The hidden state at time t of the decoder is computed by

where

h(cid:48)(cid:104)t(cid:105)
j = z(cid:48)

jh(cid:48)(cid:104)t−1(cid:105)

+ (1 − z(cid:48)

j) ˜h(cid:48)(cid:104)t(cid:105)
j ,

j

(cid:16)(cid:2)W(cid:48)e(yt−1)(cid:3)
(cid:16)(cid:2)W(cid:48)
j +(cid:2)U(cid:48)
ze(yt−1)(cid:3)
(cid:16)(cid:2)W(cid:48)
j +(cid:2)U(cid:48)
re(yt−1)(cid:3)

j + r(cid:48)

(cid:2)U(cid:48)h(cid:48)(cid:104)t−1(cid:105) + Cc(cid:3)(cid:17)
(cid:17)
zh(cid:48)(cid:104)t−1(cid:105)(cid:3)
(cid:17)
rh(cid:48)(cid:104)t−1(cid:105)(cid:3)

+ [Czc]j

+ [Crc]j

j

j

j

˜h(cid:48)(cid:104)t(cid:105)
j = tanh
z(cid:48)
r(cid:48)

j =σ

j =σ

,

,

,

and e(y0) is an all-zero vector. Similarly to the case of the encoder, e(y) is an embedding of a target
word.

Unlike the encoder which simply encodes the source phrase, the decoder is learned to generate a target

phrase. At each time t, the decoder computes the probability of generating j-th word by

p(yt,j = 1 | yt−1, . . . , y1, X) =

exp(cid:0)gjs(cid:104)t(cid:105)(cid:1)
j(cid:48)=1 exp(cid:0)gj(cid:48)s(cid:104)t(cid:105)(cid:1) ,
(cid:80)K

where the i-element of s(cid:104)t(cid:105) is

and

(cid:104)t(cid:105)
i = max

s

(cid:110)

2i−1, s(cid:48)(cid:104)t(cid:105)
s(cid:48)(cid:104)t(cid:105)

2i

(cid:111)

s(cid:48)(cid:104)t(cid:105)

= Ohh(cid:48)(cid:104)t(cid:105)

+ Oyyt−1 + Occ.

is a so-called maxout unit.

(cid:104)t(cid:105)
In short, the s
i

For the computational efﬁciency, instead of a single-matrix output weight G, we use a product of two

matrices such that

G = GlGr,

where Gl ∈ RK×500 and Gr ∈ R500×1000.
B Word and Phrase Representations
Here, we show enlarged plots of the word and phrase representations in Figs. 4–5.

Figure 6: 2–D embedding of the learned word representation. The top left one shows the full embedding space, while the other three ﬁgures show the zoomed-in
view of speciﬁc regions (color–coded).

Figure 7: 2–D embedding of the learned phrase representation. The top left one shows the full representation space (1000 randomly selected points), while the
other three ﬁgures show the zoomed-in view of speciﬁc regions (color–coded).

